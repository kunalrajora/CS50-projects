{"filter":false,"title":"framework.c","tooltip":"/pset3/framework.c","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":221,"column":0},"action":"insert","lines":["#include \"framework.h\""," ","/*","* Clears screen using ANSI escape sequences.","*/","void","clear(void)","{","    printf(\"\\033[2J\");","    printf(\"\\033[%d;%dH\", 0, 0);","}","","","/*"," * Greets player."," */","void","greet(void)","{","    clear();","    printf(\"WELCOME TO THE GAME OF FIFTEEN\\n\");","    usleep(2000000);","}","","","/*"," * Check whether the current board layout is solvable."," */","int","solvable(int d, int **board)","{","    int parity = 0;","    ","    // walk over every tile and count how many tiles before it are greater","    for(int i = 0; i < d; i++)","    {","        for(int j = 0; j < d; j++)","        {","            // when the blank is on an uneven row, add 1 to parity ","            if(board[i][j] == 0 && i % 2 == 0)","                parity++;","            ","            for(int k = 0; k < d; k++)","            {","                for(int l = 0; l < d; l++)","                {","                    if(board[k][l] < board[i][j] && board[k][l] > 0 && d*i+j < d*k+l)","                        parity++;","                }","            }","        }","    }","","    // when uneven dimension, add 1 to parity","    if(d % 2 != 0)","        parity++;","","    // when parity is even, the puzzle is solvable    ","    return(parity % 2 == 0);   ","}","","","/*"," * Initializes the game's board with tiles numbered 1 through d*d - 1"," * (i.e., fills 2D array with values but does not actually print them).  "," */","void","init(int d, int **board, int *SET_SEED, int MAX_TRIES)","{","    // fill array with numbers 0 to d*d-1","    for(int i = 0; i < d; i++)","    {","        for(int j = 0; j < d; j++)","            {","                board[i][j] = d*i + j;","            }","    }","    ","    ","    // when a seed is set, set it as seed, otherwise use the time as seed","    if (SET_SEED != NULL)","        srand((unsigned int) SET_SEED);","    else","        srand((unsigned int) time(NULL));","        ","        ","    // switch every tile with a random other tile","    int tmp, randi, randj, tries;","    while (!solvable(d, board) || tries < MAX_TRIES)","    {","        for(int i = 0; i < d; i++)","        {","            for(int j = 0; j < d; j++)","            {  ","                randi = rand() % d;","                randj = rand() % d;","            ","                tmp = board[randi][randj];","                board[randi][randj] = board[i][j];","                board[i][j] = tmp;","            }","        }","         ","        tries++;       ","    }","}","","","/* "," * Prints the board in its current state."," */","void","draw(int d, int **board)","{","    for(int i = 0; i < d; i++)","    {","        printf(\" \");","        ","        for(int j = 0; j < d; j++)","        {","            if(board[i][j] > 0)","                printf(\" %2d  \", board[i][j]);            ","            else","                printf(\" __  \");","        }","        ","        printf(\"\\n\\n\");","    }","}","","","/* "," * If tile borders empty space, moves tile and returns true, else"," * returns false. "," */","bool","move(int tile, int d, int **board)","{","    int step = 0;","    int x,y;","    ","    // find the given tile ","    for(int i = 0; i < d; i++)","    {","        for(int j = 0; j < d; j++)","        {","            if(board[i][j] == tile)","                goto found;","            ","            step++;","        }","    }","    ","    return false;","    ","    // when valid, calculate the coordinates","    found:","    y = step % d;","    x = (step - y)/d;","    ","    ","    // check if blank is up, left, down or right of tile, and swap","    if (x < d - 1 && board[x + 1][y] == 0)","    {","        board[x + 1][y] = board[x][y];","        board[x][y] = 0;","        return true; ","    }","    else if (x > 0 && board[x-1][y] == 0)","    {","        board[x - 1][y] = board[x][y];","        board[x][y] = 0;","        return true;     ","    }","    else if (y > 0 && board[x][y-1] == 0)","    {","        board[x][y - 1] = board[x][y];","        board[x][y] = 0;","        return true;     ","    }","    else if (y < d - 1 && board[x][y+1] == 0)","    {","        board[x][y + 1] = board[x][y];","        board[x][y] = 0;   ","        return true; ","    }","    ","    return false;","","}","","","/*"," * Returns true if game is won (i.e., board is in winning configuration), "," * else false."," */","bool","won(int d, int **board)","{","    int i = 0, j = 0;","    ","    if(board[d - 1][d - 1] != 0)","        return false;","    else","        while(i < d && j < d)","        {","            if(!(i == d - 1 && j == d - 1) && board[i][j] != d * i + j + 1)","                return false;","            ","            if(j == d - 1 && i < d - 1)","            {","                i++;","                j = 0;","            }","            else","                j++;","        }","    ","    return true;","}","Back to Top",""],"id":1}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":221,"column":0},"end":{"row":221,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1456630484919,"hash":"a5407990f6d315378da26e2f9dfc656809e29afa"}
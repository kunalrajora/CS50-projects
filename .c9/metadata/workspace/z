{"changed":true,"filter":false,"title":"z","tooltip":"/z","value":"//\n// server.c\n//\n// Computer Science 50\n// Problem Set 6\n//\n\n// feature test macro requirements\n#define _GNU_SOURCE\n#define _XOPEN_SOURCE 700\n#define _XOPEN_SOURCE_EXTENDED\n\n// limits on an HTTP request's size, based on Apache's\n// http://httpd.apache.org/docs/2.2/mod/core.html\n#define LimitRequestFields 50\n#define LimitRequestFieldSize 4094\n#define LimitRequestLine 8190\n\n// number of bytes for buffers\n#define BYTES 512\n\n// header files\n#include <arpa/inet.h>\n#include <dirent.h>\n#include <errno.h>\n#include <limits.h>\n#include <math.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n// types\ntypedef char BYTE;\n\n// prototypes\nbool connected(void);\nvoid error(unsigned short code);\nvoid freedir(struct dirent** namelist, int n);\nvoid handler(int signal);\nchar* htmlspecialchars(const char* s);\nchar* indexes(const char* path);\nvoid interpret(const char* path, const char* query);\nvoid list(const char* path);\nbool load(FILE* file, BYTE** content, size_t* length);\nconst char* lookup(const char* path);\nbool parse(const char* line, char* path, char* query);\nconst char* reason(unsigned short code);\nvoid redirect(const char* uri);\nbool request(char** message, size_t* length);\nvoid respond(int code, const char* headers, const char* body, size_t length);\nvoid start(short port, const char* path);\nvoid stop(void);\nvoid transfer(const char* path, const char* type);\nchar* urldecode(const char* s);\n\n// server's root\nchar* root = NULL;\n\n// file descriptor for sockets\nint cfd = -1, sfd = -1;\n\n// flag indicating whether control-c has been heard\nbool signaled = false;\n\nint main(int argc, char* argv[])\n{\n    // a global variable defined in errno.h that's \"set by system \n    // calls and some library functions [to a nonzero value]\n    // in the event of an error to indicate what went wrong\"\n    errno = 0;\n\n    // default to port 8080\n    int port = 8080;\n\n    // usage\n    const char* usage = \"Usage: server [-p port] /path/to/root\";\n\n    // parse command-line arguments\n    int opt;\n    while ((opt = getopt(argc, argv, \"hp:\")) != -1)\n    {\n        switch (opt)\n        {\n            // -h\n            case 'h':\n                printf(\"%s\\n\", usage);\n                return 0;\n\n            // -p port\n            case 'p':\n                port = atoi(optarg);\n                break;\n        }\n    }\n\n    // ensure port is a non-negative short and path to server's root is specified\n    if (port < 0 || port > SHRT_MAX || argv[optind] == NULL || strlen(argv[optind]) == 0)\n    {\n        // announce usage\n        printf(\"%s\\n\", usage);\n\n        // return 2 just like bash's builtins\n        return 2;\n    }\n\n    // start server\n    start(port, argv[optind]);\n\n    // listen for SIGINT (aka control-c)\n    struct sigaction act;\n    act.sa_handler = handler;\n    act.sa_flags = 0;\n    sigemptyset(&act.sa_mask);\n    sigaction(SIGINT, &act, NULL);\n\n    // a message and its length\n    char* message = NULL;\n    size_t length = 0;\n\n    // path requested\n    char* path = NULL;\n\n    // accept connections one at a time\n    while (true)\n    {\n        // free last path, if any\n        if (path != NULL)\n        {\n            free(path);\n            path = NULL;\n        }\n\n        // free last message, if any\n        if (message != NULL)\n        {\n            free(message);\n            message = NULL;\n        }\n        length = 0;\n\n        // close last client's socket, if any\n        if (cfd != -1)\n        {\n            close(cfd);\n            cfd = -1;\n        }\n\n        // check for control-c\n        if (signaled)\n        {\n            stop();\n        }\n\n        // check whether client has connected\n        if (connected())\n        {\n            // check for request\n            if (request(&message, &length))\n            {\n                // extract message's request-line\n                // http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html\n                const char* haystack = message;\n                const char* needle = strstr(haystack, \"\\r\\n\");\n                if (needle == NULL)\n                {\n                    error(500);\n                    continue;\n                }\n                char line[needle - haystack + 2 + 1];\n                strncpy(line, haystack, needle - haystack + 2);\n                line[needle - haystack + 2] = '\\0';\n\n                // log request-line\n                printf(\"%s\", line);\n\n                // parse request-line\n                char abs_path[LimitRequestLine + 1];\n                char query[LimitRequestLine + 1];\n                if (parse(line, abs_path, query))\n                {\n                    // URL-decode absolute-path\n                    char* p = urldecode(abs_path);\n                    if (p == NULL)\n                    {\n                        error(500);\n                        continue;\n                    }\n\n                    // resolve absolute-path to local path\n                    path = malloc(strlen(root) + strlen(p) + 1);\n                    if (path == NULL)\n                    {\n                        error(500);\n                        continue;\n                    }\n                    strcpy(path, root);\n                    strcat(path, p);\n                    free(p);\n\n                    // ensure path exists\n                    if (access(path, F_OK) == -1)\n                    {\n                        error(404);\n                        continue;\n                    }\n\n                    // if path to directory\n                    struct stat sb;\n                    if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode))\n                    {\n                        // redirect from absolute-path to absolute-path/\n                        if (abs_path[strlen(abs_path) - 1] != '/')\n                        {\n                            char uri[strlen(abs_path) + 1 + 1];\n                            strcpy(uri, abs_path);\n                            strcat(uri, \"/\");\n                            redirect(uri);\n                            continue;\n                        }\n\n                        // use path/index.php or path/index.html, if present, instead of directory's path\n                        char* index = indexes(path);\n                        if (index != NULL)\n                        {\n                            free(path);\n                            path = index;\n                        }\n\n                        // list contents of directory\n                        else\n                        {\n                            list(path);\n                            continue;\n                        }\n                    }\n\n                    // look up MIME type for file at path\n                    const char* type = lookup(path);\n                    if (type == NULL)\n                    {\n                        error(501);\n                        continue;\n                    }\n\n                    // interpret PHP script at path\n                    if (strcasecmp(\"text/x-php\", type) == 0)\n                    {\n                        interpret(path, query);\n                    }\n\n                    // transfer file at path\n                    else\n                    {\n                        transfer(path, type);\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Checks (without blocking) whether a client has connected to server. \n * Returns true iff so.\n */\nbool connected(void)\n{\n    struct sockaddr_in cli_addr;\n    memset(&cli_addr, 0, sizeof(cli_addr));\n    socklen_t cli_len = sizeof(cli_addr);\n    cfd = accept(sfd, (struct sockaddr*) &cli_addr, &cli_len);\n    if (cfd == -1)\n    {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Responds to client with specified status code.\n */\nvoid error(unsigned short code)\n{\n    // determine code's reason-phrase\n    const char* phrase = reason(code);\n    if (phrase == NULL)\n    {\n        return;\n    }\n\n    // template for response's content\n    char* template = \"<html><head><title>%i %s</title></head><body><h1>%i %s</h1></body></html>\";\n\n    // render template\n    char body[(strlen(template) - 2 - ((int) log10(code) + 1) - 2 + strlen(phrase)) * 2 + 1];\n    int length = sprintf(body, template, code, phrase, code, phrase);\n    if (length < 0)\n    {\n        body[0] = '\\0';\n        length = 0;\n    }\n\n    // respond with error\n    char* headers = \"Content-Type: text/html\\r\\n\";\n    respond(code, headers, body, length);\n}\n\n/**\n * Frees memory allocated by scandir.\n */\nvoid freedir(struct dirent** namelist, int n)\n{\n    if (namelist != NULL)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            free(namelist[i]);\n        }\n        free(namelist);\n    }\n}\n \n/**\n * Handles signals.\n */\nvoid handler(int signal)\n{\n    // control-c\n    if (signal == SIGINT)\n    {\n        signaled = true;\n    }\n}\n\n/**\n * Escapes string for HTML. Returns dynamically allocated memory for escaped\n * string that must be deallocated by caller.\n */\nchar* htmlspecialchars(const char* s)\n{\n    // ensure s is not NULL\n    if (s == NULL)\n    {\n        return NULL;\n    }\n\n    // allocate enough space for an unescaped copy of s\n    char* t = malloc(strlen(s) + 1);\n    if (t == NULL)\n    {\n        return NULL;\n    }\n    t[0] = '\\0';\n\n    // iterate over characters in s, escaping as needed\n    for (int i = 0, old = strlen(s), new = old; i < old; i++)\n    {\n        // escape &\n        if (s[i] == '&')\n        {\n            const char* entity = \"&amp;\";\n            new += strlen(entity);\n            t = realloc(t, new);\n            if (t == NULL)\n            {\n                return NULL;\n            }\n            strcat(t, entity);\n        }\n\n        // escape \"\n        else if (s[i] == '\"')\n        {\n            const char* entity = \"&quot;\";\n            new += strlen(entity);\n            t = realloc(t, new);\n            if (t == NULL)\n            {\n                return NULL;\n            }\n            strcat(t, entity);\n        }\n\n        // escape '\n        else if (s[i] == '\\'')\n        {\n            const char* entity = \"&#039;\";\n            new += strlen(entity);\n            t = realloc(t, new);\n            if (t == NULL)\n            {\n                return NULL;\n            }\n            strcat(t, entity);\n        }\n\n        // escape <\n        else if (s[i] == '<')\n        {\n            const char* entity = \"&lt;\";\n            new += strlen(entity);\n            t = realloc(t, new);\n            if (t == NULL)\n            {\n                return NULL;\n            }\n            strcat(t, entity);\n        }\n\n        // escape >\n        else if (s[i] == '>')\n        {\n            const char* entity = \"&gt;\";\n            new += strlen(entity);\n            t = realloc(t, new);\n            if (t == NULL)\n            {\n                return NULL;\n            }\n            strcat(t, entity);\n        }\n\n        // don't escape\n        else\n        {\n            strncat(t, s + i, 1);\n        }\n    }\n\n    // escaped string\n    return t;\n}\n\n/**\n * Checks, in order, whether index.php or index.html exists inside of path.\n * Returns path to first match if so, else NULL.\n */\nchar* indexes(const char* path)\n{\n    // TODO\n    return NULL;\n}\n\n/**\n * Interprets PHP file at path using query string.\n */\nvoid interpret(const char* path, const char* query)\n{\n    // ensure path is readable\n    if (access(path, R_OK) == -1)\n    {\n        error(403);\n        return;\n    }\n\n    // open pipe to PHP interpreter\n    char* format = \"QUERY_STRING=\\\"%s\\\" REDIRECT_STATUS=200 SCRIPT_FILENAME=\\\"%s\\\" php-cgi\";\n    char command[strlen(format) + (strlen(path) - 2) + (strlen(query) - 2) + 1];\n    if (sprintf(command, format, query, path) < 0)\n    {\n        error(500);\n        return;\n    }\n    FILE* file = popen(command, \"r\");\n    if (file == NULL)\n    {\n        error(500);\n        return;\n    }\n\n    // load interpreter's content\n    char* content;\n    size_t length;\n    if (load(file, &content, &length) == false)\n    {\n        error(500);\n        return;\n    }\n\n    // close pipe\n    pclose(file);\n\n    // subtract php-cgi's headers from content's length to get body's length\n    char* haystack = content;\n    char* needle = strstr(haystack, \"\\r\\n\\r\\n\");\n    if (needle == NULL)\n    {\n        free(content);\n        error(500);\n        return;\n    }\n\n    // extract headers\n    char headers[needle + 2 - haystack + 1];\n    strncpy(headers, content, needle + 2 - haystack);\n    headers[needle + 2 - haystack] = '\\0';\n\n    // respond with interpreter's content\n    respond(200, headers, needle + 4, length - (needle - haystack + 4));\n\n    // free interpreter's content\n    free(content);\n}\n\n/**\n * Responds to client with directory listing of path.\n */\nvoid list(const char* path)\n{\n    // ensure path is readable and executable\n    if (access(path, R_OK | X_OK) == -1)\n    {\n        error(403);\n        return;\n    }\n\n    // open directory\n    DIR* dir = opendir(path);\n    if (dir == NULL)\n    {\n        return;\n    }\n\n    // buffer for list items\n    char* list = malloc(1);\n    list[0] = '\\0';\n\n    // iterate over directory entries\n    struct dirent** namelist = NULL;\n    int n = scandir(path, &namelist, NULL, alphasort);\n    for (int i = 0; i < n; i++)\n    {\n        // omit . from list\n        if (strcmp(namelist[i]->d_name, \".\") == 0)\n        {\n            continue;\n        }\n\n        // escape entry's name\n        char* name = htmlspecialchars(namelist[i]->d_name);\n        if (name == NULL)\n        {\n            free(list);\n            freedir(namelist, n);\n            error(500);\n            return;\n        }\n\n        // append list item to buffer\n        char* template = \"<li><a href=\\\"%s\\\">%s</a></li>\";\n        list = realloc(list, strlen(list) + strlen(template) - 2 + strlen(name) - 2 + strlen(name) + 1);\n        if (list == NULL)\n        {\n            free(name);\n            freedir(namelist, n);\n            error(500);\n            return;\n        }\n        if (sprintf(list + strlen(list), template, name, name) < 0)\n        {\n            free(name);\n            freedir(namelist, n);\n            free(list);\n            error(500);\n            return;\n        }\n\n        // free escaped name\n        free(name);\n    }\n\n    // free memory allocated by scandir\n    freedir(namelist, n);\n\n    // prepare response\n    const char* relative = path + strlen(root);\n    char* template = \"<html><head><title>%s</title></head><body><h1>%s</h1><ul>%s</ul></body></html>\";\n    char body[strlen(template) - 2 + strlen(relative) - 2 + strlen(relative) - 2 + strlen(list) + 1];\n    int length = sprintf(body, template, relative, relative, list);\n    if (length < 0)\n    {\n        free(list);\n        closedir(dir);\n        error(500);\n        return;\n    }\n\n    // free buffer\n    free(list);\n\n    // close directory\n    closedir(dir);\n\n    // respond with list\n    char* headers = \"Content-Type: text/html\\r\\n\";\n    respond(200, headers, body, length);\n}\n\n/**\n * Loads a file into memory dynamically allocated on heap.\n * Stores address thereof in *content and length thereof in *length.\n */\nbool load(FILE* file, BYTE** content, size_t* length)\n{\n   \n    return false;\n}\n\n/**\n * Returns MIME type for supported extensions, else NULL.\n */\nconst char* lookup(const char* path)\n{\n    // TODO\n    \n    return NULL;\n}\n\n/**\n * Parses a request-line, storing its absolute-path at abs_path \n * and its query string at query, both of which are assumed\n * to be at least of length LimitRequestLine + 1.\n */\nbool parse(const char* line, char* abs_path, char* query)\n{\n    // TODO\n    error(501);\n    return false;\n}\n\n/**\n * Returns status code's reason phrase.\n *\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6\n * https://tools.ietf.org/html/rfc2324\n */\nconst char* reason(unsigned short code)\n{\n    switch (code)\n    {\n        case 200: return \"OK\";\n        case 301: return \"Moved Permanently\";\n        case 400: return \"Bad Request\";\n        case 403: return \"Forbidden\";\n        case 404: return \"Not Found\";\n        case 405: return \"Method Not Allowed\";\n        case 414: return \"Request-URI Too Long\";\n        case 418: return \"I'm a teapot\";\n        case 500: return \"Internal Server Error\";\n        case 501: return \"Not Implemented\";\n        case 505: return \"HTTP Version Not Supported\";\n        default: return NULL;\n    }\n}\n\n/**\n * Redirects client to uri.\n */\nvoid redirect(const char* uri)\n{\n    char* template = \"Location: %s\\r\\n\";\n    char headers[strlen(template) - 2 + strlen(uri) + 1];\n    if (sprintf(headers, template, uri) < 0)\n    {\n        error(500);\n        return;\n    }\n    respond(301, headers, NULL, 0);\n}\n\n/**\n * Reads (without blocking) an HTTP request's headers into memory dynamically allocated on heap.\n * Stores address thereof in *message and length thereof in *length.\n */\nbool request(char** message, size_t* length)\n{\n    // ensure socket is open\n    if (cfd == -1)\n    {\n        return false;\n    }\n\n    // initialize message and its length\n    *message = NULL;\n    *length = 0;\n\n    // read message \n    while (*length < LimitRequestLine + LimitRequestFields * LimitRequestFieldSize + 4)\n    {\n        // read from socket\n        BYTE buffer[BYTES];\n        ssize_t bytes = read(cfd, buffer, BYTES);\n        if (bytes < 0)\n        {\n            if (*message != NULL)\n            {\n                free(*message);\n                *message = NULL;\n            }\n            *length = 0;\n            break;\n        }\n\n        // append bytes to message \n        *message = realloc(*message, *length + bytes + 1);\n        if (*message == NULL)\n        {\n            *length = 0;\n            break;\n        }\n        memcpy(*message + *length, buffer, bytes);\n        *length += bytes;\n\n        // null-terminate message thus far\n        *(*message + *length) = '\\0';\n\n        // search for CRLF CRLF\n        int offset = (*length - bytes < 3) ? *length - bytes : 3;\n        char* haystack = *message + *length - bytes - offset;\n        char* needle = strstr(haystack, \"\\r\\n\\r\\n\");\n        if (needle != NULL)\n        {\n            // trim to one CRLF and null-terminate\n            *length = needle - *message + 2;\n            *message = realloc(*message, *length + 1);\n            if (*message == NULL)\n            {\n                break;\n            }\n            *(*message + *length) = '\\0';\n\n            // ensure request-line is no longer than LimitRequestLine\n            haystack = *message;\n            needle = strstr(haystack, \"\\r\\n\");\n            if (needle == NULL || (needle - haystack + 2) > LimitRequestLine)\n            {\n                break;\n            }\n\n            // count fields in message\n            int fields = 0;\n            haystack = needle + 2;\n            while (*haystack != '\\0')\n            {\n                // look for CRLF\n                needle = strstr(haystack, \"\\r\\n\");\n                if (needle == NULL)\n                {\n                    break;\n                }\n\n                // ensure field is no longer than LimitRequestFieldSize\n                if (needle - haystack + 2 > LimitRequestFieldSize)\n                {\n                    break;\n                }\n\n                // look beyond CRLF\n                haystack = needle + 2;\n            }\n\n            // if we didn't get to end of message, we must have erred\n            if (*haystack != '\\0')\n            {\n                break;\n            }\n\n            // ensure message has no more than LimitRequestFields\n            if (fields > LimitRequestFields)\n            {\n                break;\n            }\n\n            // valid\n            return true;\n        }\n    }\n\n    // invalid\n    if (*message != NULL)\n    {\n        free(*message);\n    }\n    *message = NULL;\n    *length = 0;\n    return false;\n}\n\n/**\n * Responds to a client with status code, headers, and body of specified length.\n */\nvoid respond(int code, const char* headers, const char* body, size_t length)\n{\n    // determine Status-Line's phrase\n    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1\n    const char* phrase = reason(code);\n    if (phrase == NULL)\n    {\n        return;\n    }\n\n    // respond with Status-Line\n    if (dprintf(cfd, \"HTTP/1.1 %i %s\\r\\n\", code, phrase) < 0)\n    {\n        return;\n    }\n\n    // respond with headers\n    if (dprintf(cfd, \"%s\", headers) < 0)\n    {\n        return;\n    }\n\n    // respond with CRLF\n    if (dprintf(cfd, \"\\r\\n\") < 0)\n    {\n        return;\n    }\n\n    // respond with body\n    if (write(cfd, body, length) == -1)\n    {\n        return;\n    }\n\n    // log response line\n    if (code == 200)\n    {\n        // green\n        printf(\"\\033[32m\");\n    }\n    else\n    {\n        // red\n        printf(\"\\033[33m\");\n    }\n    printf(\"HTTP/1.1 %i %s\", code, phrase);\n    printf(\"\\033[39m\\n\");\n}\n\n/**\n * Starts server on specified port rooted at path.\n */\nvoid start(short port, const char* path)\n{\n    // path to server's root\n    root = realpath(path, NULL);\n    if (root == NULL)\n    {\n        stop();\n    }\n\n    // ensure root is executable\n    if (access(root, X_OK) == -1)\n    {\n        stop();\n    }\n\n    // announce root\n    printf(\"\\033[33m\");\n    printf(\"Using %s for server's root\", root);\n    printf(\"\\033[39m\\n\");\n\n    // create a socket\n    sfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sfd == -1)\n    {\n        stop();\n    }\n\n    // allow reuse of address (to avoid \"Address already in use\")\n    int optval = 1;\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n    // assign name to socket\n    struct sockaddr_in serv_addr;\n    memset(&serv_addr, 0, sizeof(serv_addr));\n    serv_addr.sin_family = AF_INET;\n    serv_addr.sin_port = htons(port);\n    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    if (bind(sfd, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) == -1)\n    {\n        printf(\"\\033[33m\");\n        printf(\"Port %i already in use\", port);\n        printf(\"\\033[39m\\n\");\n        stop();\n    }\n\n    // listen for connections\n    if (listen(sfd, SOMAXCONN) == -1)\n    {\n        stop();\n    }\n\n    // announce port in use\n    struct sockaddr_in addr;\n    socklen_t addrlen = sizeof(addr);\n    if (getsockname(sfd, (struct sockaddr*) &addr, &addrlen) == -1)\n    {\n        stop();\n    }\n    printf(\"\\033[33m\");\n    printf(\"Listening on port %i\", ntohs(addr.sin_port));\n    printf(\"\\033[39m\\n\");\n}\n\n/**\n * Stop server, deallocating any resources.\n */\nvoid stop(void)\n{\n    // preserve errno across this function's library calls\n    int errsv = errno;\n\n    // announce stop\n    printf(\"\\033[33m\");\n    printf(\"Stopping server\\n\");\n    printf(\"\\033[39m\");\n\n    // free root, which was allocated by realpath\n    if (root != NULL)\n    {\n        free(root);\n    }\n\n    // close server socket\n    if (sfd != -1)\n    {\n        close(sfd);\n    }\n\n    // stop server\n    exit(errsv);\n}\n\n/**\n * Transfers file at path with specified type to client.\n */\nvoid transfer(const char* path, const char* type)\n{\n    // ensure path is readable\n    if (access(path, R_OK) == -1)\n    {\n        error(403);\n        return;\n    }\n\n    // open file\n    FILE* file = fopen(path, \"r\");\n    if (file == NULL)\n    {\n        error(500);\n        return;\n    }\n\n    // load file's content\n    BYTE* content;\n    size_t length;\n    if (load(file, &content, &length) == false)\n    {\n        error(500);\n        return;\n    }\n\n    // close file\n    fclose(file);\n\n    // prepare response\n    char* template = \"Content-Type: %s\\r\\n\";\n    char headers[strlen(template) - 2 + strlen(type) + 1];\n    if (sprintf(headers, template, type) < 0)\n    {\n        error(500);\n        return;\n    }\n\n    // respond with file's content\n    respond(200, headers, content, length);\n\n    // free file's content\n    free(content);\n}\n\n/**\n * URL-decodes string, returning dynamically allocated memory for decoded string\n * that must be deallocated by caller.\n */\nchar* urldecode(const char* s)\n{\n    // check whether s is NULL\n    if (s == NULL)\n    {\n        return NULL;\n    }\n\n    // allocate enough (zeroed) memory for an undecoded copy of s\n    char* t = calloc(strlen(s) + 1, 1);\n    if (t == NULL)\n    {\n        return NULL;\n    }\n    \n    // iterate over characters in s, decoding percent-encoded octets, per\n    // https://www.ietf.org/rfc/rfc3986.txt\n    for (int i = 0, j = 0, n = strlen(s); i < n; i++, j++)\n    {\n        if (s[i] == '%' && i < n - 2)\n        {\n            char octet[3];\n            octet[0] = s[i + 1];\n            octet[1] = s[i + 2];\n            octet[2] = '\\0';\n            t[j] = (char) strtol(octet, NULL, 16);\n            i += 2;\n        }\n        else if (s[i] == '+')\n        {\n            t[j] = ' ';\n        }\n        else\n        {\n            t[j] = s[i];\n        }\n    }\n\n    // escaped string\n    return t;\n}\n","undoManager":{"mark":-2,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":1035,"column":0},"action":"insert","lines":["//","// server.c","//","// Computer Science 50","// Problem Set 6","//","","// feature test macro requirements","#define _GNU_SOURCE","#define _XOPEN_SOURCE 700","#define _XOPEN_SOURCE_EXTENDED","","// limits on an HTTP request's size, based on Apache's","// http://httpd.apache.org/docs/2.2/mod/core.html","#define LimitRequestFields 50","#define LimitRequestFieldSize 4094","#define LimitRequestLine 8190","","// number of bytes for buffers","#define BYTES 512","","// header files","#include <arpa/inet.h>","#include <dirent.h>","#include <errno.h>","#include <limits.h>","#include <math.h>","#include <signal.h>","#include <stdbool.h>","#include <stdio.h>","#include <stdlib.h>","#include <string.h>","#include <strings.h>","#include <sys/socket.h>","#include <sys/stat.h>","#include <sys/types.h>","#include <unistd.h>","","// types","typedef char BYTE;","","// prototypes","bool connected(void);","void error(unsigned short code);","void freedir(struct dirent** namelist, int n);","void handler(int signal);","char* htmlspecialchars(const char* s);","char* indexes(const char* path);","void interpret(const char* path, const char* query);","void list(const char* path);","bool load(FILE* file, BYTE** content, size_t* length);","const char* lookup(const char* path);","bool parse(const char* line, char* path, char* query);","const char* reason(unsigned short code);","void redirect(const char* uri);","bool request(char** message, size_t* length);","void respond(int code, const char* headers, const char* body, size_t length);","void start(short port, const char* path);","void stop(void);","void transfer(const char* path, const char* type);","char* urldecode(const char* s);","","// server's root","char* root = NULL;","","// file descriptor for sockets","int cfd = -1, sfd = -1;","","// flag indicating whether control-c has been heard","bool signaled = false;","","int main(int argc, char* argv[])","{","    // a global variable defined in errno.h that's \"set by system ","    // calls and some library functions [to a nonzero value]","    // in the event of an error to indicate what went wrong\"","    errno = 0;","","    // default to port 8080","    int port = 8080;","","    // usage","    const char* usage = \"Usage: server [-p port] /path/to/root\";","","    // parse command-line arguments","    int opt;","    while ((opt = getopt(argc, argv, \"hp:\")) != -1)","    {","        switch (opt)","        {","            // -h","            case 'h':","                printf(\"%s\\n\", usage);","                return 0;","","            // -p port","            case 'p':","                port = atoi(optarg);","                break;","        }","    }","","    // ensure port is a non-negative short and path to server's root is specified","    if (port < 0 || port > SHRT_MAX || argv[optind] == NULL || strlen(argv[optind]) == 0)","    {","        // announce usage","        printf(\"%s\\n\", usage);","","        // return 2 just like bash's builtins","        return 2;","    }","","    // start server","    start(port, argv[optind]);","","    // listen for SIGINT (aka control-c)","    struct sigaction act;","    act.sa_handler = handler;","    act.sa_flags = 0;","    sigemptyset(&act.sa_mask);","    sigaction(SIGINT, &act, NULL);","","    // a message and its length","    char* message = NULL;","    size_t length = 0;","","    // path requested","    char* path = NULL;","","    // accept connections one at a time","    while (true)","    {","        // free last path, if any","        if (path != NULL)","        {","            free(path);","            path = NULL;","        }","","        // free last message, if any","        if (message != NULL)","        {","            free(message);","            message = NULL;","        }","        length = 0;","","        // close last client's socket, if any","        if (cfd != -1)","        {","            close(cfd);","            cfd = -1;","        }","","        // check for control-c","        if (signaled)","        {","            stop();","        }","","        // check whether client has connected","        if (connected())","        {","            // check for request","            if (request(&message, &length))","            {","                // extract message's request-line","                // http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html","                const char* haystack = message;","                const char* needle = strstr(haystack, \"\\r\\n\");","                if (needle == NULL)","                {","                    error(500);","                    continue;","                }","                char line[needle - haystack + 2 + 1];","                strncpy(line, haystack, needle - haystack + 2);","                line[needle - haystack + 2] = '\\0';","","                // log request-line","                printf(\"%s\", line);","","                // parse request-line","                char abs_path[LimitRequestLine + 1];","                char query[LimitRequestLine + 1];","                if (parse(line, abs_path, query))","                {","                    // URL-decode absolute-path","                    char* p = urldecode(abs_path);","                    if (p == NULL)","                    {","                        error(500);","                        continue;","                    }","","                    // resolve absolute-path to local path","                    path = malloc(strlen(root) + strlen(p) + 1);","                    if (path == NULL)","                    {","                        error(500);","                        continue;","                    }","                    strcpy(path, root);","                    strcat(path, p);","                    free(p);","","                    // ensure path exists","                    if (access(path, F_OK) == -1)","                    {","                        error(404);","                        continue;","                    }","","                    // if path to directory","                    struct stat sb;","                    if (stat(path, &sb) == 0 && S_ISDIR(sb.st_mode))","                    {","                        // redirect from absolute-path to absolute-path/","                        if (abs_path[strlen(abs_path) - 1] != '/')","                        {","                            char uri[strlen(abs_path) + 1 + 1];","                            strcpy(uri, abs_path);","                            strcat(uri, \"/\");","                            redirect(uri);","                            continue;","                        }","","                        // use path/index.php or path/index.html, if present, instead of directory's path","                        char* index = indexes(path);","                        if (index != NULL)","                        {","                            free(path);","                            path = index;","                        }","","                        // list contents of directory","                        else","                        {","                            list(path);","                            continue;","                        }","                    }","","                    // look up MIME type for file at path","                    const char* type = lookup(path);","                    if (type == NULL)","                    {","                        error(501);","                        continue;","                    }","","                    // interpret PHP script at path","                    if (strcasecmp(\"text/x-php\", type) == 0)","                    {","                        interpret(path, query);","                    }","","                    // transfer file at path","                    else","                    {","                        transfer(path, type);","                    }","                }","            }","        }","    }","}","","/**"," * Checks (without blocking) whether a client has connected to server. "," * Returns true iff so."," */","bool connected(void)","{","    struct sockaddr_in cli_addr;","    memset(&cli_addr, 0, sizeof(cli_addr));","    socklen_t cli_len = sizeof(cli_addr);","    cfd = accept(sfd, (struct sockaddr*) &cli_addr, &cli_len);","    if (cfd == -1)","    {","        return false;","    }","    return true;","}","","/**"," * Responds to client with specified status code."," */","void error(unsigned short code)","{","    // determine code's reason-phrase","    const char* phrase = reason(code);","    if (phrase == NULL)","    {","        return;","    }","","    // template for response's content","    char* template = \"<html><head><title>%i %s</title></head><body><h1>%i %s</h1></body></html>\";","","    // render template","    char body[(strlen(template) - 2 - ((int) log10(code) + 1) - 2 + strlen(phrase)) * 2 + 1];","    int length = sprintf(body, template, code, phrase, code, phrase);","    if (length < 0)","    {","        body[0] = '\\0';","        length = 0;","    }","","    // respond with error","    char* headers = \"Content-Type: text/html\\r\\n\";","    respond(code, headers, body, length);","}","","/**"," * Frees memory allocated by scandir."," */","void freedir(struct dirent** namelist, int n)","{","    if (namelist != NULL)","    {","        for (int i = 0; i < n; i++)","        {","            free(namelist[i]);","        }","        free(namelist);","    }","}"," ","/**"," * Handles signals."," */","void handler(int signal)","{","    // control-c","    if (signal == SIGINT)","    {","        signaled = true;","    }","}","","/**"," * Escapes string for HTML. Returns dynamically allocated memory for escaped"," * string that must be deallocated by caller."," */","char* htmlspecialchars(const char* s)","{","    // ensure s is not NULL","    if (s == NULL)","    {","        return NULL;","    }","","    // allocate enough space for an unescaped copy of s","    char* t = malloc(strlen(s) + 1);","    if (t == NULL)","    {","        return NULL;","    }","    t[0] = '\\0';","","    // iterate over characters in s, escaping as needed","    for (int i = 0, old = strlen(s), new = old; i < old; i++)","    {","        // escape &","        if (s[i] == '&')","        {","            const char* entity = \"&amp;\";","            new += strlen(entity);","            t = realloc(t, new);","            if (t == NULL)","            {","                return NULL;","            }","            strcat(t, entity);","        }","","        // escape \"","        else if (s[i] == '\"')","        {","            const char* entity = \"&quot;\";","            new += strlen(entity);","            t = realloc(t, new);","            if (t == NULL)","            {","                return NULL;","            }","            strcat(t, entity);","        }","","        // escape '","        else if (s[i] == '\\'')","        {","            const char* entity = \"&#039;\";","            new += strlen(entity);","            t = realloc(t, new);","            if (t == NULL)","            {","                return NULL;","            }","            strcat(t, entity);","        }","","        // escape <","        else if (s[i] == '<')","        {","            const char* entity = \"&lt;\";","            new += strlen(entity);","            t = realloc(t, new);","            if (t == NULL)","            {","                return NULL;","            }","            strcat(t, entity);","        }","","        // escape >","        else if (s[i] == '>')","        {","            const char* entity = \"&gt;\";","            new += strlen(entity);","            t = realloc(t, new);","            if (t == NULL)","            {","                return NULL;","            }","            strcat(t, entity);","        }","","        // don't escape","        else","        {","            strncat(t, s + i, 1);","        }","    }","","    // escaped string","    return t;","}","","/**"," * Checks, in order, whether index.php or index.html exists inside of path."," * Returns path to first match if so, else NULL."," */","char* indexes(const char* path)","{","    // TODO","    return NULL;","}","","/**"," * Interprets PHP file at path using query string."," */","void interpret(const char* path, const char* query)","{","    // ensure path is readable","    if (access(path, R_OK) == -1)","    {","        error(403);","        return;","    }","","    // open pipe to PHP interpreter","    char* format = \"QUERY_STRING=\\\"%s\\\" REDIRECT_STATUS=200 SCRIPT_FILENAME=\\\"%s\\\" php-cgi\";","    char command[strlen(format) + (strlen(path) - 2) + (strlen(query) - 2) + 1];","    if (sprintf(command, format, query, path) < 0)","    {","        error(500);","        return;","    }","    FILE* file = popen(command, \"r\");","    if (file == NULL)","    {","        error(500);","        return;","    }","","    // load interpreter's content","    char* content;","    size_t length;","    if (load(file, &content, &length) == false)","    {","        error(500);","        return;","    }","","    // close pipe","    pclose(file);","","    // subtract php-cgi's headers from content's length to get body's length","    char* haystack = content;","    char* needle = strstr(haystack, \"\\r\\n\\r\\n\");","    if (needle == NULL)","    {","        free(content);","        error(500);","        return;","    }","","    // extract headers","    char headers[needle + 2 - haystack + 1];","    strncpy(headers, content, needle + 2 - haystack);","    headers[needle + 2 - haystack] = '\\0';","","    // respond with interpreter's content","    respond(200, headers, needle + 4, length - (needle - haystack + 4));","","    // free interpreter's content","    free(content);","}","","/**"," * Responds to client with directory listing of path."," */","void list(const char* path)","{","    // ensure path is readable and executable","    if (access(path, R_OK | X_OK) == -1)","    {","        error(403);","        return;","    }","","    // open directory","    DIR* dir = opendir(path);","    if (dir == NULL)","    {","        return;","    }","","    // buffer for list items","    char* list = malloc(1);","    list[0] = '\\0';","","    // iterate over directory entries","    struct dirent** namelist = NULL;","    int n = scandir(path, &namelist, NULL, alphasort);","    for (int i = 0; i < n; i++)","    {","        // omit . from list","        if (strcmp(namelist[i]->d_name, \".\") == 0)","        {","            continue;","        }","","        // escape entry's name","        char* name = htmlspecialchars(namelist[i]->d_name);","        if (name == NULL)","        {","            free(list);","            freedir(namelist, n);","            error(500);","            return;","        }","","        // append list item to buffer","        char* template = \"<li><a href=\\\"%s\\\">%s</a></li>\";","        list = realloc(list, strlen(list) + strlen(template) - 2 + strlen(name) - 2 + strlen(name) + 1);","        if (list == NULL)","        {","            free(name);","            freedir(namelist, n);","            error(500);","            return;","        }","        if (sprintf(list + strlen(list), template, name, name) < 0)","        {","            free(name);","            freedir(namelist, n);","            free(list);","            error(500);","            return;","        }","","        // free escaped name","        free(name);","    }","","    // free memory allocated by scandir","    freedir(namelist, n);","","    // prepare response","    const char* relative = path + strlen(root);","    char* template = \"<html><head><title>%s</title></head><body><h1>%s</h1><ul>%s</ul></body></html>\";","    char body[strlen(template) - 2 + strlen(relative) - 2 + strlen(relative) - 2 + strlen(list) + 1];","    int length = sprintf(body, template, relative, relative, list);","    if (length < 0)","    {","        free(list);","        closedir(dir);","        error(500);","        return;","    }","","    // free buffer","    free(list);","","    // close directory","    closedir(dir);","","    // respond with list","    char* headers = \"Content-Type: text/html\\r\\n\";","    respond(200, headers, body, length);","}","","/**"," * Loads a file into memory dynamically allocated on heap."," * Stores address thereof in *content and length thereof in *length."," */","bool load(FILE* file, BYTE** content, size_t* length)","{","   ","    return false;","}","","/**"," * Returns MIME type for supported extensions, else NULL."," */","const char* lookup(const char* path)","{","    // TODO","    ","    return NULL;","}","","/**"," * Parses a request-line, storing its absolute-path at abs_path "," * and its query string at query, both of which are assumed"," * to be at least of length LimitRequestLine + 1."," */","bool parse(const char* line, char* abs_path, char* query)","{","    // TODO","    error(501);","    return false;","}","","/**"," * Returns status code's reason phrase."," *"," * http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6"," * https://tools.ietf.org/html/rfc2324"," */","const char* reason(unsigned short code)","{","    switch (code)","    {","        case 200: return \"OK\";","        case 301: return \"Moved Permanently\";","        case 400: return \"Bad Request\";","        case 403: return \"Forbidden\";","        case 404: return \"Not Found\";","        case 405: return \"Method Not Allowed\";","        case 414: return \"Request-URI Too Long\";","        case 418: return \"I'm a teapot\";","        case 500: return \"Internal Server Error\";","        case 501: return \"Not Implemented\";","        case 505: return \"HTTP Version Not Supported\";","        default: return NULL;","    }","}","","/**"," * Redirects client to uri."," */","void redirect(const char* uri)","{","    char* template = \"Location: %s\\r\\n\";","    char headers[strlen(template) - 2 + strlen(uri) + 1];","    if (sprintf(headers, template, uri) < 0)","    {","        error(500);","        return;","    }","    respond(301, headers, NULL, 0);","}","","/**"," * Reads (without blocking) an HTTP request's headers into memory dynamically allocated on heap."," * Stores address thereof in *message and length thereof in *length."," */","bool request(char** message, size_t* length)","{","    // ensure socket is open","    if (cfd == -1)","    {","        return false;","    }","","    // initialize message and its length","    *message = NULL;","    *length = 0;","","    // read message ","    while (*length < LimitRequestLine + LimitRequestFields * LimitRequestFieldSize + 4)","    {","        // read from socket","        BYTE buffer[BYTES];","        ssize_t bytes = read(cfd, buffer, BYTES);","        if (bytes < 0)","        {","            if (*message != NULL)","            {","                free(*message);","                *message = NULL;","            }","            *length = 0;","            break;","        }","","        // append bytes to message ","        *message = realloc(*message, *length + bytes + 1);","        if (*message == NULL)","        {","            *length = 0;","            break;","        }","        memcpy(*message + *length, buffer, bytes);","        *length += bytes;","","        // null-terminate message thus far","        *(*message + *length) = '\\0';","","        // search for CRLF CRLF","        int offset = (*length - bytes < 3) ? *length - bytes : 3;","        char* haystack = *message + *length - bytes - offset;","        char* needle = strstr(haystack, \"\\r\\n\\r\\n\");","        if (needle != NULL)","        {","            // trim to one CRLF and null-terminate","            *length = needle - *message + 2;","            *message = realloc(*message, *length + 1);","            if (*message == NULL)","            {","                break;","            }","            *(*message + *length) = '\\0';","","            // ensure request-line is no longer than LimitRequestLine","            haystack = *message;","            needle = strstr(haystack, \"\\r\\n\");","            if (needle == NULL || (needle - haystack + 2) > LimitRequestLine)","            {","                break;","            }","","            // count fields in message","            int fields = 0;","            haystack = needle + 2;","            while (*haystack != '\\0')","            {","                // look for CRLF","                needle = strstr(haystack, \"\\r\\n\");","                if (needle == NULL)","                {","                    break;","                }","","                // ensure field is no longer than LimitRequestFieldSize","                if (needle - haystack + 2 > LimitRequestFieldSize)","                {","                    break;","                }","","                // look beyond CRLF","                haystack = needle + 2;","            }","","            // if we didn't get to end of message, we must have erred","            if (*haystack != '\\0')","            {","                break;","            }","","            // ensure message has no more than LimitRequestFields","            if (fields > LimitRequestFields)","            {","                break;","            }","","            // valid","            return true;","        }","    }","","    // invalid","    if (*message != NULL)","    {","        free(*message);","    }","    *message = NULL;","    *length = 0;","    return false;","}","","/**"," * Responds to a client with status code, headers, and body of specified length."," */","void respond(int code, const char* headers, const char* body, size_t length)","{","    // determine Status-Line's phrase","    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1","    const char* phrase = reason(code);","    if (phrase == NULL)","    {","        return;","    }","","    // respond with Status-Line","    if (dprintf(cfd, \"HTTP/1.1 %i %s\\r\\n\", code, phrase) < 0)","    {","        return;","    }","","    // respond with headers","    if (dprintf(cfd, \"%s\", headers) < 0)","    {","        return;","    }","","    // respond with CRLF","    if (dprintf(cfd, \"\\r\\n\") < 0)","    {","        return;","    }","","    // respond with body","    if (write(cfd, body, length) == -1)","    {","        return;","    }","","    // log response line","    if (code == 200)","    {","        // green","        printf(\"\\033[32m\");","    }","    else","    {","        // red","        printf(\"\\033[33m\");","    }","    printf(\"HTTP/1.1 %i %s\", code, phrase);","    printf(\"\\033[39m\\n\");","}","","/**"," * Starts server on specified port rooted at path."," */","void start(short port, const char* path)","{","    // path to server's root","    root = realpath(path, NULL);","    if (root == NULL)","    {","        stop();","    }","","    // ensure root is executable","    if (access(root, X_OK) == -1)","    {","        stop();","    }","","    // announce root","    printf(\"\\033[33m\");","    printf(\"Using %s for server's root\", root);","    printf(\"\\033[39m\\n\");","","    // create a socket","    sfd = socket(AF_INET, SOCK_STREAM, 0);","    if (sfd == -1)","    {","        stop();","    }","","    // allow reuse of address (to avoid \"Address already in use\")","    int optval = 1;","    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));","","    // assign name to socket","    struct sockaddr_in serv_addr;","    memset(&serv_addr, 0, sizeof(serv_addr));","    serv_addr.sin_family = AF_INET;","    serv_addr.sin_port = htons(port);","    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);","    if (bind(sfd, (struct sockaddr*) &serv_addr, sizeof(serv_addr)) == -1)","    {","        printf(\"\\033[33m\");","        printf(\"Port %i already in use\", port);","        printf(\"\\033[39m\\n\");","        stop();","    }","","    // listen for connections","    if (listen(sfd, SOMAXCONN) == -1)","    {","        stop();","    }","","    // announce port in use","    struct sockaddr_in addr;","    socklen_t addrlen = sizeof(addr);","    if (getsockname(sfd, (struct sockaddr*) &addr, &addrlen) == -1)","    {","        stop();","    }","    printf(\"\\033[33m\");","    printf(\"Listening on port %i\", ntohs(addr.sin_port));","    printf(\"\\033[39m\\n\");","}","","/**"," * Stop server, deallocating any resources."," */","void stop(void)","{","    // preserve errno across this function's library calls","    int errsv = errno;","","    // announce stop","    printf(\"\\033[33m\");","    printf(\"Stopping server\\n\");","    printf(\"\\033[39m\");","","    // free root, which was allocated by realpath","    if (root != NULL)","    {","        free(root);","    }","","    // close server socket","    if (sfd != -1)","    {","        close(sfd);","    }","","    // stop server","    exit(errsv);","}","","/**"," * Transfers file at path with specified type to client."," */","void transfer(const char* path, const char* type)","{","    // ensure path is readable","    if (access(path, R_OK) == -1)","    {","        error(403);","        return;","    }","","    // open file","    FILE* file = fopen(path, \"r\");","    if (file == NULL)","    {","        error(500);","        return;","    }","","    // load file's content","    BYTE* content;","    size_t length;","    if (load(file, &content, &length) == false)","    {","        error(500);","        return;","    }","","    // close file","    fclose(file);","","    // prepare response","    char* template = \"Content-Type: %s\\r\\n\";","    char headers[strlen(template) - 2 + strlen(type) + 1];","    if (sprintf(headers, template, type) < 0)","    {","        error(500);","        return;","    }","","    // respond with file's content","    respond(200, headers, content, length);","","    // free file's content","    free(content);","}","","/**"," * URL-decodes string, returning dynamically allocated memory for decoded string"," * that must be deallocated by caller."," */","char* urldecode(const char* s)","{","    // check whether s is NULL","    if (s == NULL)","    {","        return NULL;","    }","","    // allocate enough (zeroed) memory for an undecoded copy of s","    char* t = calloc(strlen(s) + 1, 1);","    if (t == NULL)","    {","        return NULL;","    }","    ","    // iterate over characters in s, decoding percent-encoded octets, per","    // https://www.ietf.org/rfc/rfc3986.txt","    for (int i = 0, j = 0, n = strlen(s); i < n; i++, j++)","    {","        if (s[i] == '%' && i < n - 2)","        {","            char octet[3];","            octet[0] = s[i + 1];","            octet[1] = s[i + 2];","            octet[2] = '\\0';","            t[j] = (char) strtol(octet, NULL, 16);","            i += 2;","        }","        else if (s[i] == '+')","        {","            t[j] = ' ';","        }","        else","        {","            t[j] = s[i];","        }","    }","","    // escaped string","    return t;","}",""],"id":1}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":261,"selection":{"start":{"row":0,"column":0},"end":{"row":1035,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1458391418667}